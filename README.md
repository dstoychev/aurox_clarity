# clarity_processor
Calibration and processing for Aurox Clarity microscopy data

This will be 2 classes written in Python for controlling the Aurox Clarity instrument over usb HID and for processing image data obtained using the Clarity instrument.
 
The first class in clarity_control.py is for controlling the clarity instrument.  It uses the python hidapi module (hydapi-cython to be exact) to give access to the usb hid interface that we use to talk to the clarity unit.  Hid is good as it uses system drivers on all operating systems, but accessing hid devices from software on the host can be complex, so we think that this hidapi interface is the simplest we have found.  There are only a few commands you will need and we will put function members in for those though It should be pretty obvious how it all works.  You use this class to select filter positions, disk positions etc. and get status reports from the unit.  The hidapi module is just a wrapper for the hidapi c-library so the whole class can be can be converted to C or C++ relatively easily.
 
The second class in clarity_process.py is for processing images that have been acquired on a camera in order to get a confocal image.  This involves registration, scaling and subtraction.  By turning on the calibration LED via clarity_control, a calibration pattern of dots is projected through the microscope.  Take an image of this (a calibration image) and use it to initialise the registration maps for the processing class. You should set up a instance of the class for each filter/disk position combination that you use as the registration can be different.  After that use these objects to process other images that you acquire normally from the microscope (with the calibrarion LED turned off).  The clarity_processor class uses the opencv library, which is available as a python module, and will automatically use opencl for processing on a gpu if available.  On a macbook pro with i7 processor at 2.2GHz and Intel Iris Pro graphics, the calibration calculation takes 1.2 secs (this only needs to be done at initialisation) and then processing individual images takes about 7.5ms. We have some evidence that this final processing step is quicker in C++ (~1ms) so ultimately it might be worth rewriting the processing step using the opencv C++ library directly.  Some other processing methods have been added that show a significant (~3x) speed-up on this.  Basically this is all depends on how the data to be processed is converted to the opencv UMat class for processing.  The UMat class encompases data that is stored in GPU memory and will be processed using OPENCL.  Different routines might see different speed-up depending on the hardware used. 

Each class includes a script showing how to use the class and some example calibration images.  We have tested various bits on python versions 2.7 and 3.7 on apple and windows 10 computers.  I donâ€™t foresee any problems running on win7 or linux either.
 
