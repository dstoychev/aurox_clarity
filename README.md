# clarity_processor
Calibration and processing for Aurox Clarity microscopy data

This will be 2 classes written in Python for controlling the AUrox Clarity instrument over usb HID and for processing image data obtained using the Clarity instrument.
 
The first class in clarity_control.py is for controlling the clarity instrument.  It uses the python hidapi module (hydapi-cython to be exact) to give access to the usb hid interface that we use to talk to the clarity unit.  Hid is good as it uses system drivers on all operating systems, but accessing hid devices from software on the host can be complex, so we think that this hidapi interface is the simplest we have found.  There are only a few commands you will need and we will put function members in for those though It should be pretty obvious how it all works.  You use this class to select filter positions, disk positions etc. and get status reports from the unit.  The hidapi module is just a wrapper for the hidapi c-library so the whole class can be can be converted to C or C++ relatively easily.
 
The second class in clarity_process.py is for processing images that have been acquired on a camera in order to get a confocal image.  This involves registration, scaling and subtraction.  We project a calibration pattern of dots through the microscope.  Take an image of this (a calibration image) and use it to initialise the registration maps for the processing class. You should set up a instance of the class for each filter/disk position combination that you use as the registration can be different.  After that use the classes to process other images that you acquire normally from the microscope.  This uses the opencv library, which will automatically use opencl for processing on a gpu if available and is available as a python module.  On a macbook pro with i7 processor at 2.2GHz, the calibration calculation takes 1.2 secs (this only needs to be done at initialisation) and then processing individual images takes about 12ms. We have some evidence that this final processing step is quicker in C++ (~1ms) so ultimately it might be worth rewriting the processing step using the opencv C++ library directly.

Each class includes a script showing how to use the class and some example calibration images.  We have tested various bits on python versions 2.7 and 3.6 on apple and windows 10 computers.  I donâ€™t foresee any problems running on win7 or linux either.
 
